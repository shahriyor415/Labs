---
title: Отчёт 6
---
:toc-title: Содержание
:toc:

= Контрольные вопросы

[text-right]
--
 Выполнила студентка группы КЭ-413
 Прокопьева Ксения
--

:imagesdir: MySixtImg
:figure-caption: Рисунок
:table-caption: Таблица
:stem:



== 1. Что такое POD типы данных?
POD (plain old data - Простые данные).
Все типы делятся на две группы: объектные типы и все остальные.
К не объектным типам относятся функции, ссылки и тип void.
У таких типов, нельзя узнать размер с помощью операции sizeof.
Группа объектных типов содержит две подгруппы – POD и не-POD типы.
К POD-типам относятся:

<1> Все встроенные арифметические типы (включая wchar_t и bool).
<2> Перечисления, т.е. типы, объявленные с помощью ключевого слова enum.
<3> Указатели.
<4> POD-структуры (struct или class) и POD-объединения (union).

Чтобы структура была POD-типом, она должна удовлетворять следующим требованиям:

1. Не иметь пользовательских конструкторов, деструктора (тильда (~)) или копирующего оператора присваивания (то есть *operator=*, принимающего на входе тот же тип).
2. Не иметь базовых классов.
3. Не иметь виртуальных функций.
4. Не иметь защищенных (protected) или закрытых (private) нестатических членов данных.
5. Не иметь не статических членов данных не-POD-типов (или массивов из таких типов), а также ссылок.

== 2. Назовите все виды типов в языке С++
В язык программирования С++ данные могут подразделятся на три большие группы: простые (целые и вещественные типы), структурированные (массивы, классы) и адресные (указатели и ссылки), представленные на рисунке 1:

[#Типы данных в С++]
.Типы данных в С++
image::Figure3.png[800, 1280]

=== Простые типы данных
[#Простые типы С++]
.Простые типы данных
[options="header"]
[cols="2,1,7"]
|=====================
|Тип | Длина |Комментарий
|*bool*| 1| Представляет значения, которые могут быть или *true*, или *false*.
|*char*|1	| Используется для символов ASCII в старых строках в стиле C или в объектах std::string,
которые никогда не будут преобразовываться в Юникод.
|*unsigned char*| 1 |	Аналог байта. В С++17 стандарте появился тип std::byte
|*int*|	4 |Целочисленное значение. Выбор по умолчанию для целых чисел
|*unsigned int*| 4| Беззнаковое целое число
|*float*| 4	|Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами
|*double*| 8	|Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей
точкой
|=====================

=== Структурированные типы данных
На базе простых типой данных можно определить собственный тип.
Любой класс или структура, определенная разработчиком, будет являться пользовательским типом.

=== Адресные типы
Каждой переменной содержащей данные соответствует некий адрес памяти.
К переменной можно обратиться непосредственно обращаясь к самой переменной,
либо можно обратиться косвенно, через указатель или ссылку.

Указатель это переменная, которая хранит адрес какой-то другой переменной:
[source, cpp]

----
#include <iostream>

int j=256; // Глобальная переменная  #<1>

int main()
{
  auto* ptr =reinterpret_cast<char*>(&j); #<2>
}
----
[.notes]
--
<1> Объявляем переменную *j* типа *int*
<2> объявляем указатель *ptr* на переменную *j* типа *char*
--

[#Указатель]
.Указатель
image::Figure5_1.png[400, 400]

Помимо указателей к адресным типам данных относятся и ссылки.
Ссылка это псевдоним переменной, характеризующаяся следущими свойствами:

• У ссылки нельзя взять адрес. Если применить оператор взятия адреса к ней, то будет
выведен адрес переменной, на которую она ссылается
• Ссылка ведет себя почти также как константный указатель. Её нельзя изменять,
складывать, вычитать
• Ссылки нельзя сравнивать
• Ссылка не может быть не проинициализирована

== 3. Что такое пользовательский тип?
Это тип данных, который описывает сам разработчик, например, классы относятся к пользовательскому типу.


== 4. Назовите модификаторы типов
[#Встроенные типы С++ модификаторы]
.Встроенные типа С++ модификаторы
[options="header"]
[cols="2,1, 7"]
|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

== 5. Назовите правило установки размеров типов
Размеры типов не четко определены и могут отличаться для различных микроконтроллеров.
Для размеров типов существует правило:
[.source, cpp]
----
1             <= sizeof(char)     <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----

Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
std::uint32_t:: целое беззнаковое длиной 32 бита
std::int64_t::  целое знаковое длинной 64 бита
std::uint8_t:: целое знаковое длинной 8 бит

== 6. Что делает оператор sizeof()?
Этот оператор позволяет определить (вывести в консоль) количество байт, занимаемое тем или иным типом данных в зависимсоти от того на какой "машине" проверяется.

== 7. Что характеризует тип std::size_t
Это специальный тип результата оператора sizeof().

size_t - это тип используемый для адресации,
например, этот тип хорошо использовать в качестве индекса массива,
т.к. в таком случае нельзя будет выйти за пределы адресного пространстрва
на исполняемой машине.

Длина size_t равна максимально возможному адресу на конкртеной машине (степени двойки).
Например, на ARM адресное пространстров 32 битное, и size_t тоже 32 битный.

== 8. Назовите фиксированные типы целых в библиотеке std
Фиксированные типа - это теже встроенные типы в С++.

image::VstroennieType.png[]

== 9. Что такое псевдоним типа?
Второе имя типа данных, которое объявляется с помощью ключевого слова *using*:
[source, cpp]
----
int main() {
  using tU32 = unsigned int ;  # <1>
  tU32 i = 10U ;               # <2>
}
----
[.notes]
--
<1> Объявляем псевдоним типа unsigned int
<2> Определяем переменную типа unsigned int
--

== 10. Что такое явное и неявное преобразование типа?
=== Неявное преобразование типов
Компилятор может неявно преобразовывать один тип к другому типу.
[.source, cpp]
----
char b = 10;   // Литерал типа int
bool c = 0;    // Литерал типа int
----
Но так лучше никогда не делать. Грамотно будет всегда явно указывать тип
данных, чтобы в дальнейшем не было ошибок.

=== Явное преобразование типов
Так как компилятор автоматически присваивая типы данных может сделать
то, что не ожидается, то не нужно использовать неявное преобразование типа.

Вместо этого, лучше указать компилятору явное преобразование из одного
типа в другой.

Для преобразований из одного типа в другой используют 4 вариантов преобразования:

* static_cast
* const_cast
* reinterpret_cast
* dynamic_cast

== 11. Какие явные преобразования типов вы знаете?
=== static_cast

*static_cast* позволяет сделать приведение близких типов
(целые, пользовательских типов которые могут создаваться из типов который
приводится, и указатель на void* к указателю на любой тип).

Проверка производится на уровне компиляции, так что в случае ошибки сообщение
будет получено в момент сборки приложения или библиотеки.
[.source, cpp]
----
auto i = static_cast<std::uint32_t>(52534525U);
----
[.notes]
--
static_cast - преобразовывает число, находящееся в круглых скобка к типу,
прописанному в треугольных скобках.
--

=== reinterpret_cast
*reinterpret_cast* преобразует типы, несовместимыми друг с другом, например
указатель преобразовать в целочисленный тип. Такое преобразование может
любой тип данных преобразовать в лбой другой, поэтому необходимо использовать его
только там где это необходимо и не злоупотреблять им, т.к. он может и
преобразовать в другой тип то, что нам не нужно и получить ерунду.

[.source, cpp]
----
auto i = reinterpret_cast<volatile uint32_t *>(0x40010000) ; // Преобразует адрес 0x40010000 в указатель типа volatile uint32_t
----

== 12. Что делает reinterpret_cast?
Позволяет преобразовать несовместимые друг с другом типы данных.

== 13. Чем static_cast отличается от reinterpret_cast?
Как уже было сказано выше:
*reinterpret_cast* преобразует типы, несовместимыми друг с другом, а
*static_cast* позволяет сделать приведение близких типов (int, char, float и др.).

== 14. Что такое ОЗУ и ПЗУ?
ОЗУ - оперативное запоминающее устройство - энергозависимая память, которая позволяет перезаписывать и считывать данные.
ПЗУ - постоянное запоминающее устройство - энергонезависимая память, которая хранит данные и позволяет их только считывать.

== 15. Каков размер памяти ARM Cortex микроконтроллеров.
Это 32-битный микроконтроллер, размер памяти до 2^32 бит.


== 16. По какой архитектуре разработан ARM Cortex микроконтроллер?
ARM  является модифицированной гарвардской архитектурой.
[#Архитектуры микропроцессоров]
.Архитектуры микропроцессоров
image::Figure22.png[800, 800]

== 17. В чем отличие Гарвардской архитектуры от Архитектура ФонНеймана?

Архитектура ФонНеймона состоит из единого блока памяти,
в котором хранятся и команды, и данные,
и общей шины для передачи данных и команд в ЦПУ и от него. Данная архитектура
приемлема в том случае, когда все действия могут выполняться последовательно.

Однако для быстрой обработки сигналов больше подходит гарвардская архитектура.
Данные и код программы хранятся в различных блоках памяти
и доступ к ним осуществляется через разные шины.
Т.к. шины работают независимо, выбор команд программы и данных
может осуществляться одновременно, повышая таким образом скорость
по сравнению со случаем использования одной шины в архитектуре ФонНеймана.

== 18. Где располагаются локальные переменные?
Локальные переменные располагаются в регистрах *R0-R3*, *R12* или на стеке.

== 19. Где располагаются статические переменные?
Статические переменные. Они инициализируются единожды.

Static означает, что та память, которая была выделена под эту переменную не
будет изменяться и закрепляется за этой переменной до конца работы приложения.
Такая переменная создаётся в памяти процессора.

== 20. Где располагаются глобальные переменные?
В памяти процессора.

== 21. Что такое стек?
Стек это организация данных по принципу "Последний пришел первый ушел".
Это означает, что новые данные вначале помещаются на вершину
(первый уровень) стека, а затем, с поступлением следующих данных,
"проталкиваются" на его нижние уровни.
Извлечение из стека происходит в обратном порядке:
вначале считываются данные,
помещенные последними на вершину, после чего данные,
размещенные на нижних уровнях, как бы "выталкиваются" на один уровень вверх.

Стек - это особая область памяти данных,
используемая процессором для временного хранения адресов возврата из
подпрограмм, промежуточных результатов вычислений.

== 22. Что такое указатель?
Указатель - это объект, который указывает на адрес переменной (хранит адрес переменной).
Без указателя не обойтись при динамическом выделении памяти или создании объектов с помобщью оператора new,
однако в своих проектах мы не используем ни динамическую память,
ни оператор new, для того чтобы код писать как можно более надежнее,
но люди используют указатели в более больших проектах.

Структура объявления указателя:

image::StructuraYkazatela.png[]

*[переменная] - разъименование адреса, т.е. возвращает значение переменной (что по этому адресу хранится)


== 23. Что такое разыменовывание указателя?
Из рисунка выше, звёздочка после типа переменной
*[переменная] - означает разыменование адреса, т.е. возвращает значение переменной (что по этому адресу хранится)

== 24. Что означает взятие адреса?
Оператор (&[переменная]) помещает в переменную типа указатель - адрес, где хранится переменная, на которую ссылается этот указатель.

== 25. Какие операции можно выполнять над указателями?
Указатели можно складывать, вычитать, сравнивать.

== 26. Что такое константный указатель?
Это указатель, содержащий адрес переменной, который нельзя изменить.

== 27. Что такое указатель на константу?
Это указатель, который хранит адрес константы (числа, которое нельзя поменять)

== 28. Что такое ссылка? В чем её отличие от указателя?
Ссылка это псевдоним переменной.

[source, cpp]
----
int main(){
  int a = 0;
  int &ref = a ;                // Объявляем ссылку на переменную *а*
  ref = 10;                     // Записываем в переменную *а* число 10
  cout << &ref << ": " << ref ; // Выводим адрес перменной *а* и значение переменной *a*
  return 0 ;
}
----
[.notes]

* У ссылки нельзя взять адрес.
Если применить оператор взятия адреса к ней, то будет выведен адрес
переменной, на которую она ссылается
* Ссылка ведет себя почти также как константный указатель.
* Ссылка не может быть не проинициализирована.

== 29. Что такое регистр?
Регистром называется функциональный узел,
предназначенный для приема, хранения, передачи и преобразования информации.
Регистры используются для построения внутренних запоминающих устройств
процессора или внешнего устройства.
Конктретно в микроконтроллере это сверхбыстрая память,
работающая на частоте процессора.

== 30. Что такое регистры общего назначения?
Регистры общего назначения расположены
внутри ядра микроконтроллера(сверхбыстрая память).
Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для
хранения адресов и промежуточных результатов вычислений
(регистр общего назначения/регистр данных)
или данных, необходимых для работы самого процессора.

== 31. Что такое регистры специального назначения?
Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления
процессором и периферийными устройствами.

== 32. Как можно установить бит в регистре специального назначения?
Чтобы установить бит в регистр специального назначения необходимо обратиться к регистру, его полю и задать значение в его поле.
Например, вот таким образом:
[source, cpp]
----
*reinterpret_cast<uint32_t *>(0x40010000) |= 1 << 0 ; // Запишем единицу в нулевой бит ячейки памяти (регистра) по адресу 0x40010000
----
== 33. Объясните как вызывается функция
Когда происходит вызов функции, то происходит сохранение вспомогательных регистров
в стек. Также в регистр LR помещается адрес откуда была выбрана функция, а регистр
LR уже помещает в стек это значение адреса.
При выходе же из функции, происходи восстановление значений из стека в регистры  *R4-R11*
и возврат к адресу, откуда ушли по адресу из регистра LR.

== 34. Что такое трансляция?
Это перевод исходного текста программы, написанного на языке программирования понятного человеку, на язык, понятный процессору — в машинные коды.
Этот процесс состоит из нескольких этапов.
Рисунок иллюстрирует эти этапы для языка С++:

image::Translator.png[]

== 35. Что такое компоновка?
Все внешние ссылки можно использовать для создания исполняемой программы или библиотеки динамической компоновки.
Компилятор выдает предупреждающие сообщения или сообщения об ошибках во время преобразования, если обнаруживает синтаксические ошибки.
Компоновщик разрешает все внешние ссылки и создает исполняемую программу или DLL, объединяя одну или несколько отдельных обработанных записей преобразования со стандартными библиотеками, но
поскольку у нас встроеное ПО, то динамически линкуемых библиотек нет (DLL), есть только статичесие бибилиотеки.

== 36. Как лучше организовывать структуру проекта и почему?
Организовывать так, чтобы разные блоки функций выполнялись в разных файлах. Следует делать эти функции максимально универсальными.

== 37. Что такое операторы?
Операторы управляют процессом выполнения программы.
Набор операторов языка С++ содержит управляющие конструкции структурного программирования.

== 38. Какие арифметические операторы вы знаете?

1. Присваивание *c = 5* - присваивает переменной значение.
2. Сложение *a+b* - суммирует два числа.
3. Вычитание *a-b* - возвращает разность двух чисел, если они числовые.
4. Унарный плюс *+a*  - ничего не делает с числами, однако, если операнд является не числом, то унарный плюс преобразует операнд в число.
5. Унарный минус *-а* - изменяет знак операнда на противоположный.
6. Умножение *а*с* - вычисляет произведение операндов.
7. Деление *а/с* - делит левый операнд на правый.
8. Остаток от деления * 5%3 * - вычисляет остаток от деления левого операнда на правый.
9. Инкремет *&#43;&#43;а* - увеличивает переменную на единицу.
10. Декремент *а--* - уменьшает переменную на единицу.

== 39. Какие логические операторы вы знаете?
1. Логическое отрицание, НЕ *!а* - выполняет логическое отрицание операнда, возвращая true, если операнд имеет значение false, и false, если операнд имеет значение true.
2. Логическое умножение, И *а&&b* - вычисляет логическое И для всех своих операндов. Результат операции x & y принимает значение true, если оба оператора x и y имеют значение true. В противном случае результат будет false.
3. Логическое сложение, ИЛИ *а++с* - вычисляет логическое исключение ИЛИ для всех своих операндов, возвращая true для x ^ y, если x имеет значение true и y имеет значение false или x имеет значение false и y имеет значение true.

== 40. Какие побитовые операторы вы знаете?
1. Побитовая инверсия *~b* - инвертирует биты (т.е. заменяет нули на единицы и наоборот).
2. Побитовое И *а&b* - позволяет сбрасывать биты в 0.
3. Побитовое ИЛИ *&#124;   | a &#124; b* - устанавливае 1 в заданные биты.
4. Побитовое исключающее ИЛИ *a ^ b* - выполняет операцию «Исключающее ИЛИ» над каждой парой бит.
5. Побитовый сдвиг влево *a* << *b* - умножение числа на 2 ^ b.
6. Побитовый сдвиг вправо *a* >> *b* - деление числа на 2 ^ b.

== 41. Приведите пример переопределения оператора
[source, c++]
--
template<typename T>
struct Complex
{
  Complex(T r, T im): real{r}, imaginary{im} {} ;
  operator T { return sqrt(real*real + imaginary* imaginary) ;}
  Complex operator +(Complex value) // перегруженный оператор +
  {
  return Complex(real+ value.real, imaginary + value.imaginary) ;
  }
  private:
  T real; //вещественная часть
  T imaginary //мнимая часть
} ;
int main()
{
  Complex<float> value1(3.0f, 4.0f) ;
  Complex<float> value1(1.0f, 2.0f) ;
  value1 += value2 ;
  return 0;
}

--

== 42. Какие еще операторы вы знаете?
sizeof - возвращает размер переменной.
&[имя_переменной] - возвращает адрес переменной.
*[переменная] - разыменование указателя.

== 43. Как сбросить бит с помощью битовых операторов?
Бит можно сбросить с помощью побитовой операции И с помощью маски.
Напрмиер, необходимо получить из числа 1 0 0 1 0 0 1 1 число 1 0 0 1 0 0 0 0.

1 0 0 1 0 0 1 1

&

1 1 1 1 1 1 0 0

1 0 0 1 0 0 0 0

Здесь число 1 1 1 1 1 1 0 0 - является маской.

== 44. Как установить бит с помощью битовых операторов?
Бит можно установить в 1 с помощью побитового оператора ИЛИ.
Напрмиер, необходимо получить из числа 1 0 0 1 0 0 1 1 число 1 1 0 1 0 0 1 1.

1 0 0 1 0 0 1 1

+

0 1 0 0 0 0 0 0

1 1 0 1 0 0 1 1

== 45. Как поменять значение бита с помощью битовых операторов?
[source, c++]
--
bit ^= 1<<n // меняет бит, сдвинутый на n
--

== 46. Какой микроконтроллер на отладочной плате XNUCLE ST32F411?
XNUCLEO-F411RE – это отладочная плата от компании Waveshare с поддержкой Arduino, которая позволит изучить возможности микроконтроллера STM32F411RET6 на базе ядра Cortex-M3.

== 47. Какие блоки входят в состав микроконтроллера STM32F411?

<1> Много источников тактирования.
<2> Спец система для перезагрузки процессора в случае его зависания.
<3> Подсчёт контрольной суммы.
<4> Контроллер прерывания.
<5> Интерфейс для отладки.
<6> Две шины (высокочастотная и для периферийных устройств).
<7> 512 кбайт памяти.
<8> 128 кбайт ОЗУ.
<9> АЦП для измерения температуры, напряжения.
<10> Куча таймеров.
<11> И периферия такие как Uart, usb.

[#Микроконтроллер]
.Функциональные блоки микроконтроллера STM32F411
image:Figure7.png[600, 600]


== 48. В чем отличие ядра CortexM4 от CortexM3?
В ядра CortexM4 увеличен набор инструкций.
И имеется аппаратный модуль работы с плавающей точкой.

== 49. Назовите основные характеристики микроконтроллера STM32F411
Ядро ARM Cortex-M4 32 разрядное, 512кБайт памяти контроллера и 128кБайт ОЗУ.
16 разрядные и 32 разрядные таймеры.
USB 2.0
Блок работы с числами с плавающей точкой FPU.
Аппаратный подсчет контрольной суммы памяти программ CRC.
Встроенный 12 битный 16 канальный АЦП.
SDIO интерфейс для карт SD/MMC/eMMC.
Работа на частотах до 100Мгц.
81 портов ввода вывода.
Питание от 1.7 до 3.6 Вольт.
Потребление 100 мкА/Мгц.

== 50. Назовите дополнительные характеристики микроконтроллера STM32F411
1. Настраиваемые источники тактовой частоты.
2. Настраиваемые на различные функции порты.
3. Внутренний температурный сенсор.
4. Таймеры с настраиваемым модулем ШИМ.
5. DMA для работы с модулями (SPI, UART, ADC… ).
6. 12 разрядный ADC последовательного приближения.
7. Часы реального времени.
8. Системный таймер и спец. прерывания для облегчения и ускорения работы ОСРВ.

== 51. Какие источники тактирования есть у микроконтроллера STM32F411
HSI - внутренний генератор с частотой 16мГц.
HSE  - внешний генератор с частотой 8мГц.
PLL - система ФАПЧ с набором делителей, для тактирования необходимой частоты.
LSI (low-speed internal) - низкочастотный внутренний RC-генератор на 37 кГц.
LSE (low-speed external) - низкочастотный внешний источник на 32,768 кГц.

== 52. Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411
* Определить какие источники частоты нужны​
** Например, PLL нужен для USB​

* Включить нужный источник​
** Используя Clock Control register (RCC::CR)​

* Дождаться стабилизации источника ​
** Используя соответствующие биты (..RDY) Clock Control register ​(RCC::CR)

* Назначить нужный источник на системную частоту​
** Используя Clock Configuration Register (RCC::CFGR)​

* Дождаться пока источник не переключиться на системную частоту​
** Используя Clock Configuration Register (RCC::CFGR)​

== 53. Что такое ФАПЧ?
ФАПЧ - это не генератор, а набор из
умножителей и делителей, исходный
сигнал он получает от HSI (внетреннего) или HSE (внешнего) генератора, а
на выходе у него уже другая частота.

== 54. Что делает следующий код?
[source, cpp]
--
int main()
{
    int StudentUdacha = 10; // Присваивает значение 10 переменной типа int. Размерность переменной при этом определяется архитектурой микроконтроллера и в нашем случае составляет 4 байта
    int PrepodUdachca = 0 ; // // Присваивает значение 10 переменной типа int. Размерность переменной при этом определяется архитектурой микроконтроллера и в нашем случае составляет 4 байта
    StudentUdacha = StudentUdacha ^ PrepodUdachca ; // ^ - побитовая операция исключающее ИЛИ, которое вернёт 10
    PrepodUdachca = StudentUdacha ^ PrepodUdachca ; // тоже вернёт 10
    StudentUdacha ^= PrepodUdachca ; // ^= - означает побитовую операцию исключающее ИЛИ между переменными StudentUdacha и PrepodUdachca и присвоение ответа переменной StudentUdacha, которая будет равна 10
}
--
Результат выполнения исключающего ИЛИ выглидит следующим образом:

image::OR.png[]

На рисунке в целях экономии места были введены следующие упрощения:

1. StudentUdacha = St
2. PrepodUdachca = Pr
3. Так же из 4 байт, был представлен только 1 младший байт для расчёта побитового исключающего ИЛИ для переменных StudentUdacha и PrepodUdachca

Когд меняет местами значения двух переменных.




== Вывод
Я ответила на 54 вопроса.

