---
title: Отчёт 8
---

:reproducible:

:description: Project_8
:keywords: AsciiDoc
:imagesdir: Project_8
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[text-right]
--
 Выполнила студентка группы КЭ-413
 Прокопьева Ксения
--
[.notes]
С++ - объекто-ориентированный язык программирования, это означает, что он
построен на классах и объектах. И в нём действуют 4 главных правила:

1. Абстракция. Это создание и описание объекта и его функций (методов).
2. Наследование. Это, когда созданный объект перенимает свойства родительского объекта.
3. Инкапсуляция. Это сокрытие от пользователя функционала объектов, на
основе которых строится более сложный объект.
4. Полиморфизм. Это присваение двум разным объектам одни и теже поведенческих функции (методы).

== Постановка задачи
Для того, чтобы написать правильно работающий код с возможностью
расширения функционала, необходимо продумать дизайн программы.
Продумка дизайна позволит писать код проще (т.е. строчки кода будут короче и читабельнее),
а также позволит адаптировать программу.

По заданию требуется написать программу "Гирлянда", которая может
управлять светодиодами, и по кнопке переключать режимы:

- мигание всеми светодиодами
- мигание светодиодами в шахматном порядке
- "Ёлочка"

Как уже было сказано, разработку программы стоит начинать с дизайна.
Для этих целей хорошо подойдёт UML диаграмма, котора позволит выстроить
логические цепочки.

Сперва необходимо определиться с абстракциями (т.е. существительными, объектами, которые
будут присутствовать в гирлянде). Любая абстракция представляется классом, который имеет описание.
В данном случае абстракциями будут:

- пины (Pin)
- кнопка (Button)
- светодиоды (LED)
- режимы (IMode)
- гирлянда (Garland)

Другими словами, мы создаём гирлянду, которая по нажатию кнопки, переключает режимы, которые
по-разному светят светодиодами, которые прикреплены к пину (ножке микроконтроллера).

Исходя из поставленной задачи будем по ней двигаться с конца в начало, для того, чтобы сперва
описать внутренние составляющие гирлянды (пины), затем светодиоды, затем режимы и в конце саму гирлянду.

=== Первая абстракция - пины

Первая абстракция будет *Pin*, у которого есть 2 состояния: быть включенным и быть выключенным.
Так же, пин может переключаться из состояния 1 в 0 и наоборот, а ещё с пина можно считать его состояние.
К тому же пин привязан к порту и чтобы была возможность передавать на пин любой порт (GPIOA,
GPIOB, GPIOC и т.д.) с любым номером порта, можно создать шаблонный класс, в который будем передавать
порт и номер порта.

Таким образом мы создаём класс *pin* и два интерфейса от которых будет наследоваться пин:

- *IPinReadable*, который будет наследоваться пином, отвечающим за кнопку.
- *IPin*, который будет наследоваться пином, отвечающим за светодиод.

В этих интерфейсах функции нереализуются, а только объвляются, поэтому данные функции будут
виртуальными *virtual*.
Вся реализация этих функций описывается в заголовочном файле *pin.h*.

.Создание класса *Pin* и интерфейсов *IPinReadable* и *IPin*
image::Создание объекта Pin и интерфейсов .png[]

Интерфейс *IPin* будет в себе содержать описание функций (методов), которые необходимы для работы
с пинами светодиодов:

- функция Reset - позволит выключить пин (сбросить пин в 0);
- функция Toggle - позволит переключить состояние пина на противоположное.

Данные функции являются публичными *public*, т.к. могут вызываться другими функциями. Для того
чтобы внутри этих функций никакие атрибуты не изменялись используем const=0, проще говоря
мы не можем изменить переменные внутри константной функции. Константная функция (const) применяется
только в том случае, если внутри этой функции не будет изменяющихся атрибутов (переменных).

.Интерфейс ipin.h
[source, c++]
-------
// Интерфейс класса Pin
#ifndef IPIN_H //Защита от двойного подключения заголовочного файла
#define IPIN_H //Защита от двойного подключения заголовочного файла

class IPin
{
public: // Публичные методы
  virtual void Reset() const=0;   //  Сбрасывает пин в 0
  virtual void Toggle() const=0 ; // виртуальный метод, у которого нет реализации
};
#endif //Защита от двойного подключения заголовочного файла
-------
Интерфейс *IPinReadable* будет в себе содержать описание функций (методов), которые необходимы
для работы с пинами кнопки:

- функция IsHigh - позволяет считать состояние пина.

Данная функции являются публичной *public* и константной *const*.

.Интерфейс IPinReadable.h
[source, c++]
-------
// Интерфейс класса Считывание состояния кнопки
#ifndef IPINREADABLE_H
#define IPINREADABLE_H

class IPinReadable
{
public:
  virtual bool IsHigh() const=0; // позволяет считать состояние ножки
};
#endif
-------
Заголовочный файл класса *Pin* будет в себе содержать описание функций (методов), которые
необходимы для работы с пинами:

- функция Set - устанавливает пин в 1;
- функция Reset - позволит выключить пин (сбросить пин в 0);
- функция Toggle - позволит переключить состояние пина на противоположное;
- функция IsHigh - позволяет считать состояние ножки.

Все функции данного класса являются публичными *public* и константными *const*, т.к. необходимо
будет вызывать эти функции из других функций и в этих функциях нет изменяющихся параметров. Также
функции *Reset()*, *Toggle()* и *IsHigh()* являются переопределёнными *override* функциями, т.к.
эти методы присутствуют в наследуемых *Pin*-ом интерфейсах (методы присутствуют в *IPinReadable.h*
и *ipin.h*), метода *Set()* нет в наследуемых интерфейсах, поэтому он не переопределяется.

.Класс pin.h
[source, c++]
-------
#ifndef PIN_H //Защита от двойного подключения заголовочного файла
#define PIN_H //Защита от двойного подключения заголовочного файла

#include "ipin.h" // подключение интерфейса пина для светодиодов
#include "IPinReadable.h" // подключение интерфейса пина для кнопки

template<typename TPort, int pinNum> // Отменяет привязку к типу порта, теперь можно сюда передать номер с любого порта (GPIOC, GPIOА)
class Pin: public IPin, public IPinReadable // Pin - класс наследник (наследование)
{
  public:
  void Set() const //  устанавливает пин в 1
  {
    TPort::ODR::Set(1U << pinNum);
  }

  void Reset() const override
  {
    auto value = TPort::ODR::Get();
    value &=~(1U << pinNum);
    TPort::ODR::Write(value);
  }
  void Toggle() const override //override - переопределение функции, которые есть в наследуемом классе интерфейсе
  {
    TPort::ODR::Toggle(1U << pinNum);
  }

  bool IsHigh() const override // Считывание состояние ножки
  {
    auto value = TPort::IDR::Get(); //получили значение входного регистра с состоянием ножек,
    return ( (value & (1U << pinNum) ) == (1 << pinNum) ); // проверка на единичный бит
  }
};
#endif //Защита от двойного подключения заголовочного файла
-------
Таким образом была сделана абстракция для пина, котоая привязывается к конкретному порту и к
конкретному номеру ножки.

=== Вторая абстракция - светодиоды

Вторая абстракция будет *LED*, у которого есть 2 состояния:
переключаться из состояния 1 в 0 и наоборот и гаснуть.
К тому же отдельный светодиод привязан к ножке процессора и при создании объекта типа LED
передадим объкту LED ножку порта к которой светодиод привязан.

Таким образом мы создаём класс *LED* и интерфейс *ILED* от которого будет наследоваться светодиод.

.Создание объекта LED с интерфейсом ILED
image::Создание объекта LED с интерфейсом ILED.PNG[]

Интерфейс *ILED* будет в себе содержать виртуальные функции (методы), которые необходимы для работы
со светодиодами:

- функция SwithOff - позволяет выключить светодиод;
- функция Toggle - позволит переключить состояние светодиода на противоположное.

Данные функции являются публичными *public*, т.к. могут вызываться другими функциями, константными
*const*, т.к. нет необходимости изменять переменные внутри этих функций и виртуальными *virtual*,
т.к. описываются в другом месте.

.Интерфейс ILED.h
[source, c++]
-------
//Интерфейс класса Led
#ifndef ILED_H
#define ILED_H

class ILed
{
public:
  virtual void SwithOff() const=0; // виртуальный метод выключения светодиода
  virtual void Toggle() const=0; // виртуальный метод переключения светодиода из 1 в 0 или обратно
};
#endif
-------

В интерфейсе функции нереализуются, а только объвляются.
Вся реализация этих функций описывается в файле *LED.cpp*.

.Заголовочный файл LED.h
[source, c++]
-------
#ifndef  LED_H
#define  LED_H

#include "ILED.h" // подключение интерфейса светодиода
#include "ipin.h" // подклчение интерфейса пина

class Led : public ILed // наследование LED от интерфейса ILED
{
public:
   Led(const IPin& pin) ; // конструктор в который передаётся ссылка на класс типа IPin

//----------Переопределяются, т.к. они уже есть в интерфейсе--------------------
   void SwithOff() const override; // переопределяемый метод выключение светодиода
   void Toggle() const override;  // переобпределяемый метод переключение светодиода
//------------------------------------------------------------------------------

private: // приватный атрибут, который хранит ссылку на интерфейс (его инициализация находится в LED.cpp)
    const IPin& _pin;
};
#endif
-------

.Исполняемый файл LED.сpp
[source, c++]
-------
#include "LED.h" // подключение заголовочного файла LED

Led::Led(const IPin& pin): _pin(pin) // инициализация ссылки на объект IPin
{

}
// потушить светодиод
void Led::SwithOff() const
{
  _pin.Reset(); // у IPin есть метод Reset(), который сбрасывает пин в 0
}

// переключить светодиод
void Led::Toggle() const
{
  _pin.Toggle(); // у IPin есть метод Toggle(), который переключает пин из одного состояния в противоположное
}
-------

Затем создами *pinconfig.h* для того, чтобы здесь задавать привязку к пинам. Чтобы светодиоды были
привязаны только к абстрактному классу, а не к выводам микроконтроллера непосредственно.
Аналогично создадим и для кнопки.

.Класс pinconfig.h
[source, c++]
-------
#ifndef  PINCONFIG_H
#define  PINCONFIG_H

#include "pin.h"

//-----------------------------Светодиоды---------------------------------------
inline constexpr Pin<GPIOC, 6> pinC6;
inline constexpr Pin<GPIOC, 7> pinC7;
inline constexpr Pin<GPIOC, 8> pinC8;
inline constexpr Pin<GPIOC, 9> pinC9;
//------------------------------------------------------------------------------

inline constexpr Pin<GPIOC, 13> pinC13; // кнопка
#endif
-------

И напишем часть кода в main.cpp. Подключим необходимые заголовочники и создадим 4 объекта
светодиода, и из них массив.

.Главный файл main.сpp
[source, c++]
-------
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
#include "gpioaregisters.hpp" // регистр для порта a

#include "pinconfig.h" // подкючение привязанных пинов к портам МК
#include "LED.h"   // подключение заголовочного файла

#include <iostream> // подключение стандартной библиотеки С++
#include <array> // подключение библиотек для работы с массивами

// -------------------------Функция задержки-----------------------------------
void Delay(uint64_t value)
{
  for(uint64_t i = 0;i<value;++i)
  {
    volatile uint64_t j = i;
  }
}
//------------------------------------------------------------------------------

//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinC6); // светодиод 1
Led led2(pinC7); // светодиод 2
Led led3(pinC8); // светодиод 3
Led led4(pinC9); // светодиод 4
//------------------------------------------------------------------------------

//---------------------------------Массива из светодиодов-----------------------
    tArrayLeds leds =
    {
      &led1,
      &led2,
      &led3,
      &led4,
    };
//------------------------------------------------------------------------------

int main()
{
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт С перевести в режим вывода (С.6 С.7 С.8 С.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
}
-------

=== Третья абстракция - кнопка

Третья абстракция будет *Button*, у которого есть 1 метод *IsPressed()*, который показывает
состояние кнопки (кнопка нажата - возвращается true, кнопка не нажата - false).
Так же как и светодиод, кнопка использует пин микроконтроллера, поэтому будем передавать в конструктор
пины через интерфейс IPinReadable.
К тому же каждая отдельная кнопка привязана к ножке процессора и при создании объекта типа Button
передадим объкту Button ножку порта к которой кнопка привязана в файле .

Таким образом мы создаём класс *Button* и интерфейс *IButton* от которого будет наследоваться кнопка.

.Создание объекта Button и его интерфейса
image::Создание объекта Button и его интерфейса.PNG[]

Интерфейс *IButton* будет в себе содержать функции (методы), которые необходимы для работы
с кнопками:

- функция IsPressed - показывает состояние кнопки (Нажата / не нажата).

.Интерфейс IButton.h
[source, c++]
-------
//Интерфейс класса кнопки
#ifndef IBUTTON_H
#define IBUTTON_H

class IButton
{
public:
  virtual bool IsPressed() const=0; // // виртуальный метод, который возвращается значение, показывающее состояние кнопки (нажата или нет)
};

#endif
-------

.Заголовочный файл Button.h
[source, c++]
-------
#ifndef  BUTTON_H
#define  BUTTON_H

#include "IButton.h" // подключение интерфейса Button
#include "iPinReadable.h" // подключение интерфейса считывания

class Button : public IButton // наследование Button от интерфейса IButton
{
public:
  Button(const IPinReadable& pin) ; // конструктор в который передаётся ссылка на класс типа IPin
  bool IsPressed() const override; // переопределяющийся методы, который возвращает нажата ли кнопка

private: // приватный атрибут, который хранит ссылку на интерфейс (его инициализация находится в Button.cpp)
    const IPinReadable& _pin;
};

#endif
-------
В интерфейсе функции нереализуются, а только объвляются.
Вся реализация этих функций описывается в файле *Button.cpp*.

.Класс Button.сpp
[source, c++]
-------
#include "Button.h" // подключение заголовочного файла Button

Button::Button(const IPinReadable& pin): _pin(pin) // инициализация ссылки на объект IPin
{

}
// Кнопка нажата
bool Button::IsPressed() const
{
    if( !_pin.IsHigh() )  // Если кнопка не нажата
    {
        while (!_pin.IsHigh()) // Если в како-то момент времени кнопка нажалась, то режим меняем
        {
           volatile int a = 1; // ничего не делающая строчка, нужна для ожидания пока кнопка обратно не отпустится
        }
        return true;
    }
    return false;
}
-------
И в main.cpp добавим строчку, создания нового объекта кнопки, туда где создавали
объекты светодиодов:

.Класс main.сpp
[source, c++]
-------
...
//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinC6); // светодиод 1
Led led2(pinC7); // светодиод 2
Led led3(pinC8); // светодиод 3
Led led4(pinC9); // светодиод 4
Button userButton1(pinC13); // Добавили объект кнопка
//------------------------------------------------------------------------------
...
-------

=== Четвёртая абстракция - режимы

Четвёртой абстракцией будут режимы, у которых есть 2 общих метод *Clear()* и
*Update()*.

*Update()* позволяет обновить состояние светодиодов. Кадый режим содержит метод
*Update()*, поэтому его реализаця находится в интерфейсе *IMode*.

*Clear()* позволяет сбросить в 0 все светодиоды. Данный метод переопределяется
для режима в шахмотном порядке (ChessMose), потому что должен не все светодиоды
гасить а только через одного(либо все чётные, либо все нечётные).

.Создание режимов
image::Создание режимов.PNG[]

Обе функции будут публичными *public*  и константными *const*, т.к. эти методы могут
вызываться из других частей программы и при этом массив из светодиодов не должен меняться.
Так же массив из светодиодов помимо того, что не должен изменяться, так ещё и передаваться он
может только классам наследникам *IMode* (наследники - это все различные режимы), поэтому
является *protected*.

.Интерфейс IMode.h
[source, c++]
-------
//Интерфейс для различных режимов
#ifndef IMODE_H
#define IMODE_H

#include <array> // подключение библиотеки массивов
#include "ILED.h" // подключение интерфейса LED

using tArrayLeds = std::array<ILed*,4>;

class IMode
{
public:
  IMode(const tArrayLeds& leds): _leds(leds) // инициализация ссылки на объекты-светодиоды
  {

  }
// Функция переключения светодиодов из одного состояния в другое
  virtual void Update() const
  {
     for(auto& it:_leds)
     {
        it->Toggle();
     }
  };
// Функция, выключающая светодиоды
  virtual void Clear() const
  {
    for(auto& it:_leds)
    {
       it->SwithOff();
    }
  };

protected:
   const tArrayLeds& _leds; // конструктор может использоваться только классами наследниками
};
#endif
-------

В данном интерфейсе функции и объявляются и реализуются.

Таким образом, мы создаём 2 класса режимов *AllMode* (мигание всеми),
*ChessMode* (мигание в шахматном порядке) которые будут наследоваться от интерфейса *IMode*.

Опишем режим *AllMode*, который должен просто моргать всеми светодиодами.

.Заголовочный файл AllMode.h
[source, c++]
-------
//заголовочный файл для режима "Моргать всеми"
#ifndef ALLMODE_H
#define ALLMODE_H

#include "IMode.h" // подключение интерфейса IMode
#include "iled.h" // подключение интерфейса LED

class AllMode: public IMode // наследование режима моргания от интерфейса IMode
{
public:
   AllMode(const tArrayLeds& leds) ; // Передача светодиодов в режим моргания
};
#endif
-------

.Исполняемый файл AllMode.сpp
[source, c++]
-------
#include "AllMode.h" // подключение заголовочника

AllMode::AllMode(const tArrayLeds& leds): IMode(leds) // наследование всех функций (методов) он интерфейса IMode
{
  
}
-------

Далее опишем режим *ChessMode*, который должен моргать светодиодами в шахматном порядке.

.Заголовочный файл ChessMode.h
[source, c++]
-------
//заголовочный файл для режима "Шахматы"
#ifndef CHESSMODE_H
#define CHESSMODE_H

#include "IMode.h" // подключение инерфейса IMode
#include  "ILED.h" // подключение интерфейса LED

class ChessMode: public IMode // наследование режима шахмат от интерфейса IMode
{
public:
   ChessMode(const tArrayLeds& led) ; // передача светодиодов в режим шахмат
   void Clear() const override ; // переопределённая функция выключения светодиодов
};
#endif
-------

.Исполняемый файл ChessMode.сpp
[source, c++]
-------
#include "ChessMode.h" // подключение заголовочника

ChessMode::ChessMode(const tArrayLeds& leds): IMode(leds) // Наследование всех функций (методов) от интерфейса IMode
{
  Clear(); // переопределённая функция
}

void ChessMode::Clear() const // реализация переопределённой функции
{
    for (std::uint32_t i = 0; i < std::size(_leds); ++i)
    {
      if ((i % 2) == 0)
      {
         _leds[i]->Toggle();
      }
    }
}
-------

=== Пятая абстракция - гирлянда

Последняя абстракция *Garland*, у которого есть две функции:

- UpdateCurrentMode(), который обновляет состояние режима;
- SwithNextMode(), который переключает режим.

Таким образом мы создаём класс *Garland* в который будет передаваться массив из режимов.

.Создание объекта Garland
image::Создание объекта Garland.png[]

Все методы являются публичными *public*, т.к. будут вызываться из другой части программы,
также метод *SwithNextMode()* не является константным, т.к. в нём будет находится счётчик,
изменяющий своё значение. Этот счётчик и массив из светодиодов, не должны быть видны пользователю,
поэтому будут являться приватными *private* (инкапсуляция - сокрытие внутренних частей).

.Заголовочный файл Garland.h
[source, c++]
-------
//Интерфейс для различных режимов
#ifndef GARLAND_H
#define GARLAND_H

#include <array> // подключение библиотеки массивов
#include "IMode.h" // подключение интерфейса

using tArrayModes = std::array<IMode*, 4>; // передача массива из режимов
class Garland
{
public:
  Garland(const tArrayModes& modes): _modes(modes) // инициализация ссылки на массив режимов
  {

  }

  void UpdateCurrentMode() const // обновление состояния текущего режима
  {
     _modes[modeNumber]->Update();
  };

  void SwithNextMode() // переключение режима на следующий
  {
    if (modeNumber == (_modes.size()-1))
    {
      modeNumber = 0;
    }
    else
    {
      modeNumber ++;
    }
    _modes[modeNumber]->Clear(); // сброс всех светодиодов
  };

private:
   uint32_t modeNumber = 0; // счётчик режимов
   const tArrayModes& _modes;
};
#endif
-------

И напишем код в main.cpp. Подключим необходимые заголовочники и создадим объекты:
светодиоды, кнопка, режимы и гирлянда.

.Главный файл main.сpp
[source, c++]
-------
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
#include "gpioaregisters.hpp" // регистр для порта a

#include "pinconfig.h" // подкючение привязанных пинов к портам МК
#include "LED.h"   // подключение заголовочного файла
#include  "Button.h" // для кнопки
#include "AllMode.h" // режим горят все
#include "ChessMode.h" // режим шахматы
#include "TreeMode.h" // режим ёлочка
#include "Garland.h" // гирлянда

#include <iostream> // подключение стандартной библиотеки С++
#include <array> // подключение библиотек для работы с массивами
// -------------------------Функция задержки-----------------------------------
void Delay(uint64_t value)
{
  for(uint64_t i = 0;i<value;++i)
  {
    volatile uint64_t j = i;
  }
}
//------------------------------------------------------------------------------

//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinC6); // светодиод 1
Led led2(pinC7); // светодиод 2
Led led3(pinC8); // светодиод 3
Led led4(pinC9); // светодиод 4
Button userButton1(pinC13); // кнопка
//------------------------------------------------------------------------------

//---------------------------------Массива из светодиодов-----------------------
    tArrayLeds leds =
    {
      &led1,
      &led2,
      &led3,
      &led4,
    };
//------------------------------------------------------------------------------

//-------------Создание объектов (режимов) с массивом из светодиодов------------
  AllMode allMode(leds);
  ChessMode chessMode(leds);
//------------------------------------------------------------------------------

//----------------------------------Массив из режимов--------------------------
    using tArrayModes = std::array<IMode*,2>;
    tArrayModes modes =
    {
      &allMode,
      &chessMode,

    };
//------------------------------------------------------------------------------

//-------------Создание объекта (гирлянда) с привязкой к режимам----------------
  Garland garland(modes);
//------------------------------------------------------------------------------

int main()
{
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт С перевести в режим вывода (С.6 С.7 С.8 С.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();

  for(;;)  // вечный цикл
  {
    Delay(100000);
    if(userButton1.IsPressed()) // Если кнопка нажата
    {
      garland.SwithNextMode(); // Меняем режим
    }
    Delay(1000000);
    garland.UpdateCurrentMode(); // обновляем текущий режим светодиодов
  }
}
-------

=== Добавление режимов "Ёлочка" и "Горочка"

Код, который был продуман с возможносью расширения и независимости от платформы, легче изменять
и добавлять что-то новое. Так в законченную гирлянду из двух режмов, можно добавить ещё два
режима, описав их в отдельных файлах и прописав наследование к *IMode*.

.Добавление режимов Ёлочка и Горочка
image::Добавление режимов Ёлочка и Горочка.png[]

Опишем режим "Ёлочка". Данный режим должен загорать светодиоды по порядку, от первого до последнего
и тушить в том же порядке. Следовательно необходимо будет переопределить один метод *Update()*. В
данном режиме понадобится счётчик, который бы считал светодиоды (все ли светодиоды загорелись).
Для этого счётчик скроем от пользователя инкапсуляцией *private*.

.Заголовочный файл TreeMode.h
[source, c++]
-------
//заголовочный файл для режима "Ёлочка"
#ifndef TREEMODE_H
#define TREEMODE_H

#include "IMode.h"
#include  "Iled.h"

class TreeMode: public IMode
{
public:
   TreeMode(const tArrayLeds& led) ; // передача массива из светодиодав
   void Update() override ;  // переопределение функции

private:
  uint32_t ledNumber = 0; // индекс светодиода
};
#endif
-------

.Исполняемый файл TreeMode.сpp
[source, c++]
-------
#include "TreeMode.h"

TreeMode::TreeMode(const tArrayLeds& leds): IMode(leds)
{
  Clear();  // нужна для сброса всех светодиодов в 0 в начальный момент переклчения на данный режим
}

void TreeMode::Update()
{
  _leds[ledNumber]->Toggle();  // переключаем светодиод на противоположное состояние
  if(ledNumber == (size(_leds)-1)) // если дошли до конца массива светодиодав
  {
      ledNumber = 0; // то начинаем с начала
  }
  else
  {
      ledNumber++; // иначе переходим к следующему светодиоду
  }
}
-------

Далее опишем режим "Горочка". Данный режим должен зажигать сперва два крайних светодиода, затем
идя к середине зажигать второй и предпоследний и т.д. После того, как все будут зажжены, тогда
светодиоды должны тухнуть с центра и до краёв. Данный режим также подразумевает переопределение
функции *Update()*. И также, как и в режиме "Ёлочка" потребуется счётчик светодиодов, а также
флаг (переменная типа bool), отвечающий за прямой и обратный ход зажигания светодиодов.

.Заголовочный файл SlideMode.h
[source, c++]
-------
//заголовочный файл для режима "Горочка"
#ifndef SLIDEMODE_H
#define SLIDEMODE_H

#include "IMode.h" // подключение инерфейса IMode
#include  "ILED.h" // подключение интерфейса LED

class SlideMode: public IMode // наследование режима шахмат от интерфейса IMode
{
public:
   SlideMode(const tArrayLeds& led) ; // передача светодиодов в режим шахмат
   void Update() override ; // переопределённая функция выключения светодиодов

private:
  uint32_t ledNumber = 0;  //  индекс светодиода
  bool revers = false;    // Флаг, отвечающий за прямой и обратной ход светодиодов
};

#endif
-------

.Исполняемый файл SlideMode.сpp
[source, c++]
-------
#include "SlideMode.h" // подключение заголовочника режима горочка

SlideMode::SlideMode(const tArrayLeds& leds): IMode(leds) // Наследование всех функций (методов) от интерфейса IMode
{
  Clear();  // нужна для сброса всех светодиодов в 0
}

void SlideMode::Update()  // реализация переопределённой функции
{
  _leds[ledNumber]->Toggle(); // переключаем с начала светодиод из одного состояния в другое
  if (ledNumber != (size(_leds) - 1 - ledNumber)) // если номера светодиодов с конца и начала не встретились,
  {
    _leds[size(_leds) - 1 - ledNumber]->Toggle(); // то переключаем с конца светодиод на противоположное состояние
  }
  if (!revers) // если прямой ход
  {
     if(ledNumber < ( ((size(_leds) + 1) / 2) -1 ) ) // если индекс светодиода не дошёл до середины
     {
        ledNumber ++ ; // то прибавляем индекс светодиода
     }
     else
     {
       revers = true; // идём в обратном порядке
     }
  }
  else  // если обратный ход
  {
     if(ledNumber > 0) // пока индекс светодиода снова не станет 0
     {
        ledNumber --; //  идём в обратном порядке
     }
     else
     {
       revers = false; // как только индекс светодиода стал = 0, переходим в прямой ход
     }
  }
}
-------
Добавим в *main.cpp* два новосозданных режима.

.Исполняемый файл Main.сpp
[source, c++]
-------
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
#include "gpioaregisters.hpp" // регистр для порта a

#include "pinconfig.h" // подкючение привязанных пинов к портам МК
#include "LED.h"   // подключение заголовочного файла
#include  "Button.h" // для кнопки
#include "AllMode.h" // режим горят все
#include "ChessMode.h" // режим шахматы
#include "TreeMode.h" // режим ёлочка
#include "SlideMode.h" // режим горочка
#include "Garland.h" // гирлянда

#include <iostream> // подключение стандартной библиотеки С++
#include <array> // подключение библиотек для работы с массивами
// -------------------------Функция задержки-----------------------------------
void Delay(uint64_t value)
{
  for(uint64_t i = 0;i<value;++i)
  {
    volatile uint64_t j = i;
  }
}
//------------------------------------------------------------------------------

//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinC7); // светодиод 1
Led led2(pinC8); // светодиод 2
Led led3(pinC9); // светодиод 3
Led led4(pinC6); // светодиод 4
Button userButton1(pinC13); // кнопка
//------------------------------------------------------------------------------

//---------------------------------Массива из светодиодов-----------------------
    tArrayLeds leds =
    {
      &led1,
      &led2,
      &led3,
      &led4,
    };
//------------------------------------------------------------------------------

//-------------Создание объектов (режимов) с массивом из светодиодов------------
  AllMode allMode(leds);
  ChessMode chessMode(leds);
  TreeMode treeMode(leds);
  SlideMode slideMode(leds);
//------------------------------------------------------------------------------

//----------------------------------Массив из режимов--------------------------
    using tArrayModes = std::array<IMode*,4>;
    tArrayModes modes =
    {
      &allMode,
      &chessMode,
      &treeMode,
      &slideMode,
    };
//------------------------------------------------------------------------------

//-------------Создание объекта (гирлянда) с привязкой к режимам----------------
  Garland garland(modes);
//------------------------------------------------------------------------------

int main()
{
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт С перевести в режим вывода (С.6 С.7 С.8 С.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();

  for(;;)  // вечный цикл
  {
    if(userButton1.IsPressed()) // Если кнопка нажата
    {
      garland.SwithNextMode(); // Меняем режим
    }
    Delay(1000000);
    garland.UpdateCurrentMode(); // обновляем текущий режим светодиодов
  }
}
-------

Результат работы гирлянды с четырьмя режимами и чётным количеством светодиодов представлен в видео.

.4 Режима с чётным количеством светодиодов
https://youtube.com/shorts/p6zSZbCn2ok?feature=share

С нечётным количеством светодиодов.

.4 Режима с нечётным количеством светодиодов
https://youtube.com/shorts/VU6DPAY6SFE?feature=share

=== Шаблоны проектирования - паттерн "Наблюдатель"
Наблюдатель — это поведенческий паттерн проектирования,
который создаёт механизм подписки,
позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

В нашу задачу можно внедрить такой паттерн для того чтобы была возможность
отслеживать нажатие кнопки и сообщать всем подписчикам.

.Паттерн "Наблюдатель"
image::Паттерн Наблюдатель.png[]

Данный патерн состоит из двух интерфейсов:

- IButtonObservable - который выполняет действия в момент нажатия на кнопку;
- IObservable - который может добавлять и удалять подписчиков.

Для их реализации создадим в *Components* папку *Observer*,
где и будут находится данные интерфейсы.

.Создание папки Observer с двумя заголовочными интерфейсными файлами
image::Создание папки Observer.png[]

Класс *IButtonObservable* содержит в себе метод *OnButtonPress()*,
который по сути является собитием *При нажатии на кнопку*.

.Заголовочный интерфейсный файл IButtonObserver.h
[source, c++]
-------
#ifndef IBUTTONOBSERVER_H
#define IBUTTONOBSERVER_H

class IButtonObserver // Класс собитий кнопки
{
  public:
  virtual void OnButtonPress () = 0; // Обработчик собития на нажатия на кнопку, будет вызываться при нажатии на кнопку
};

#endif
-------

Унаследуем *IButtonObservable* классом гирлянды *Garland*, где и реализуем метод *OnButtonPress()*.

.Заголовочный файл Garland.h
[source, c++]
-------
//Интерфейс гирлянды
#ifndef GARLAND_H
#define GARLAND_H
#include <iostream>          // подключение стандартной библиотеки
#include <array>             // подключение библиотеки массивов
#include "IMode.h"           // подключение интерфейса режимов
#include "IButtonObserver.h" // подключение интерфейса собитий кнопки

using tArrayModes = std::array<IMode*, 4>; // передача массива из режимов (4 режима)
class Garland : public IButtonObserver // Класс гирлянды, наследует интерфейс собитий кнопки
{
public:
  Garland(const tArrayModes& modes): _modes(modes) // инициализация ссылки на массив режимов
  {

  }

  void UpdateCurrentMode() const // обновление состояния текущего режима
  {
     _modes[modeNumber]->Update();
  };

  void SwitchNextMode() // переключение режима на следующий
  {
    if (modeNumber == (_modes.size()-1))
    {
      modeNumber = 0;
    }
    else
    {
      modeNumber ++;
    }
    _modes[modeNumber]->Clear(); // сброс всех светодиодов
  };

  void OnButtonPress () override // собитие, при нажатии на кнопку
  {
    SwitchNextMode(); // переключиться на следующий режим
  }

private:
   uint32_t modeNumber = 0;    // счётчик режимов
   const tArrayModes& _modes;  // массив из режимов (4 штуки)

};

class Gyru : public IButtonObserver // Класс какого-то другого объекта (полиморфизм)
{
    void OnButtonPress () override // собитие, при нажатии на кнопку
  {
    std::cout<<"кнопка нажата"<<std::endl;  // вывести в терминал
  }
};
#endif
-------

Далее опишем интерфейс *IObservable*, который работает с подписчиками.

.Заголовочный интерфейсный файл IObservable.h
[source, c++]
-------
#ifndef IOBSERVABLE_H
#define IOBSERVABLE_H

#include "IButtonObserver.h" // подключение интерфейса собитий кнопки

class IObservable // Интерфейсный класс, который работает с подписчиками
{
  public:
   virtual void AddObserver (IButtonObserver& observer) = 0;     // Добавление нового подписчика в массив подписчиков, IButtonObserver& observer - ссылка на того, кого будем оповещаем
   virtual void RemoveObserver (IButtonObserver& observer) = 0; // Удаление из массива подписчиков
};
#endif
-------

Т.к. собитие связано с кнопкой (при нажатии на кнопку), то следует отправиться в *Button.h*
и описать новые методы и атрибуты.

.Заголовочный файл Button.h
[source, c++]
-------
#ifndef  BUTTON_H
#define  BUTTON_H
#include <array>             // подключение стандартной библиотеки массивов

#include "IButton.h"         // подключение интерфейса Button
#include "iPinReadable.h"    // подключение интерфейса считывания пина
#include "IButtonObserver.h" // подключение интерфейса событий кнопки
#include "IObservable.h"     // подключение интерфейса, который работает с подписчиками

class Button : public IButton, public IObservable // наследование Button от интерфейса IButton
{
public:
   Button(const IPinReadable& pin) ; // конструктор в который передаётся ссылка на класс типа IPin
   bool IsPressed() const override; // переопределяющийся методы, который возвращает нажата ли кнопка

   void AddObserver(IButtonObserver& observer) override;     // добавление подписчиков в массив подписчиков
   void RemoveObserver (IButtonObserver& observer) override; // Удаление из массива подписчиков

private: // приватный атрибут, который хранит ссылку на интерфейс (его инициализация находится в Button.cpp)
   const IPinReadable& _pin;
   std::array<IButtonObserver*, 4> _observers;  // массив из 4 подписчиков
   int32_t _currentObserver = -1;               // начальное значение индекса подписчиков
};
#endif
-------
И реализовать сами методы в файле *Button.срр*
.Исполнительный файл Button.срр
[source, c++]
-------
#include "Button.h"          // подключение заголовочного файла Button
#include "IButtonObserver.h" // подключение интерфейса событий кнопки
#include "IObservable.h"     // подключение интерфейса, который работает с подписчиками

Button::Button(const IPinReadable& pin): _pin(pin) // инициализация ссылки на объект IPin
{

}
// Кнопка нажата
bool Button::IsPressed() const
{
  if( !_pin.IsHigh() )  // Если кнопка не нажата
  {
      while (!_pin.IsHigh()) // Если в како-то момент времени кнопка нажалась, то режим меняем
      {
         volatile int a = 1; // ничего не делающая строчка, нужна для ожидания пока кнопка обратно не отпустится
      }
      for (int i = 0; i <= _currentObserver; i ++) // проход по массиву подписчиков
      {
        _observers[i]->OnButtonPress(); // оповещает каждого подписчика о том, что кнопка нажата
      }
      return true;
  }
  return false;
}

void Button::AddObserver(IButtonObserver& observer) // добавление наблюдателя (до 4 штук)
{
  _currentObserver++; // переменная отвечающая за индекс подписчика в массиве
  _observers[_currentObserver] = &observer; // помещает в массив объект, которого будет оповещать
}

void Button::RemoveObserver(IButtonObserver& observer) // удаление из массива подписчиков
{
  for (int i = 0; i <= (_currentObserver); i ++) // проход по массиву подписчиков
  {

    if ( _observers[i] == &observer) // Если нашли то что нужно выкинуть,
    {
       for (int j = i; j <= (_currentObserver - 1); j ++) // то снова проходим по массиву подписчиков и
       {
           _observers[j] = _observers[j + 1]; // перезаписываем
       }
       _currentObserver--;
    }
  }
}
-------
Итого получем следующую UML-диаграмму:

.UML-диаграмма с паттерном наблюдатель
image::Добавление шаблона Наблюдателя.png[]


== Вывод
Я узнала что существуют 4 важных принципа ООП: абстракция, полиморфизм,
наследование и инкапсуляция, которые позволяют создавать красивый, читабельный
и коротки код.
Создала программу Гирлянда, которая управляет различными режимами. Программа
написана таким образом, чтобы была возможность добавлять новые режимы,
дополнительные пины.
Также большая часть программы полностью независима от железа. Зависимость
остаётся только на этапе подключения пинов и подачи тактирования (питания) на
ножки микроконтроллера.
Далее я реализовала паттерн проектирования "Наблюдатель",
который позволяет оповещать о событиях своих подписчиков.

