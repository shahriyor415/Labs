---
title: Отчёт по операционной системе реального времени (ОСРВ)
---

:reproducible:

:description: Rabota_4
:keywords: AsciiDoc
:imagesdir: ImgRabota_4
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[text-right]
--
 Выполнила студентка группы КЭ-413
 Прокопьева Ксения
--
[.notes]

== ОСРВ (RTOS)
Предназначена для обеспечения своевремености выполнения обработки данных,
а также позволяет облегчить разработку программного обеспечения (ПО).

Т.е. ОСРВ нужня для того чтобы обеспечить реакцию на определённое действие за отведённое время.

Задачей ОСРВ является обеспечение реакции системы на определённое действие за отведённый квант времени.

Время реакции системы на событие - это временной интервал от события на объекте и
до выполнения первой инструкции в программе обработки этого события.
Т.е. это некая задерка между событием, произошедшем в реальности и тем как микроконтроллер начал обрабатывать это событие.

ОСРВ занимает место во Flash-памяти, тем самым это увеличивает стоимость микроконтроллера, который бы вмещал в себе ОСРВ.

Когда следует использовать ОСРВ:

1. Когда есть вероятность что ПО расширится.
2. Если требуется гарантировать время отклика на событие.
3. Когда многозадачная система (или псевдомногозадачная система)

Многозадачность (псевдомногозадачность) - это одновременное выполнение нескольких задач
(выполнене каждой задачи в отведённое ей время, что и создаёт эффект,
что микроконтроллер (МК) выполняет параллельно несколько задач).

Задача - это минипрограмма.
В нашем случае каждая задача - это бесконечный цикл,
в котором функция выполняется а потом засыпает на определённое (заданное) время.
Задача имеет свой собственный стек, где храняться значения переменных, а также приоритет.
Задачу можно созать, удалить, её оповестить и перевести в режим ожидания.

Традиционно существуют 2 версии многозадачности:

    - Мягкого реального времени (как пример ОС Windows, потому что в ней под каждую задачу отводится
определённое время и если программа не успевает выполниться, она зависает, потому что после её
выполнения по мнению планировщика запустилась другая программа)
    - Жёсткого реального времени (это ОСРВ, потому что здесь задача должна выполниться, даже если её
время истекло и это не должно приводить к зависаниям)

У ОСРВ вытесняющий вид многозадачности - это означает, что при выполнении задачи может прийти ещё одна задача,
тогда, если прошлая задача не успела выполниться, то новая задача её вытеснит, выполнится и по завершении новой задачи,
начнёт снова выполняться прошлая задача. При этом у задач также имеется приоритет.
Т.е. вытеснять могут только те задачи. которые выше по приоритету, чем вытесняемые.
Но при этом, чтобы низкоприоритетная задача хоть когда-нибудь выполнилась, высокоприоритетные задачи
должны выполняться очень быстро. Иначе высокоприоритетная долгая задача только выполнится,
как снова наступит её черёд выполняться, и тогда низкоприоритетные задачи не смогут выполниться.

Принцип работы и запуск задач похож на то как срабатывают прерывания.
Когда программа выполняет некую низкприоритетную задачу 1,
с каждым тиком (обычно берутся маленькие значения, например 1 миллисекунда),
происходит прерывание по системному таймеру в котором запускается планировщик.
Планировщик пробегает по всем задачам и запускает самую высокоприоритетную готовую к запуску задачу.
А дальше как в прерывании, планировщик берёт адрес задачи, сохраняет данные из прошлой задачи и запускает новую,
затем после выполнения новой задачи, планировщик возвращается к предыдущей задачи, восстановив данные и адрес прошлой задачи.

=== Работа с ОСРВ
Создадим задачи, одна задача будет моргать одним светодиоом со скоростью 200 миллисекунд,
а другая задача - другим светодиодом со скоростью 100 миллисекунд.
Для этого создадим 2 класса: *MyLED*, который будет отвечать за светодиод 8,
и *MyLED9* - за светодиод 9. Данные классы опишем в файлах *myled.h* и *MyLED9.h* и *MyLED9.срр* соответственно.

Данные классы должны наследоваться от класса потока *Thread*.
Данный класс позволяет создавать и вызывать задачи.

.Файл myled.h
[source, c++]
-------
#ifndef MYLED_H
#define MYLED_H

#include "thread.hpp" // подключим библиотеку для класса Thread

using OsWrapper::Thread;      // пространсво имён для класса потока, чтобы была возможность в дальнейшем к нему обращать без длинного обращения "OsWrapper::Thread"
using OsWrapper::StackDepth;  // пространсво имён чтобы была возможность без длинного имени определять объём стека в задаче

template<typename TOutputRegister, std::uint32_t bitNum> // шаблонный класс для моргания светодиодом
class MyLED: public Thread<static_cast <std::size_t>(StackDepth::minimal)>
{
public:
  MyLED(std::chrono::milliseconds period): _period(period) // стандартная библиотека С++, в которую передадим определённое количество миллисекунд
  {

  }

  void Execute() override;   // переопределили метод для класса

private:
  std::chrono::milliseconds _period; // стандартная библиотека С++, в которую передадим определённое количество миллисекунд
};

template<typename TOutputRegister, std::uint32_t bitNum>             // bitNum - номер порта светодиода
void MyLED<TOutputRegister, bitNum>::Execute()    // и сразу же опишем переопределённый метод Execute()
{
    for(;;)
    {
      TOutputRegister::Toggle(1<<bitNum);
      Sleep(_period);
    }
}
#endif //LEDS_H
-------

.Файл MyLED9.h
[source, c++]
-------
#ifndef MYLED9_H
#define MYLED9_H

#include "thread.hpp"

using OsWrapper::Thread;
using OsWrapper::StackDepth;

class MyLED9: public Thread<static_cast <std::size_t>(StackDepth::minimal)>
{
public:
     MyLED9() = default;
     void Execute() override;
};


#endif //LEDS_H
-------

.Файл MyLED9.cpp
[source, c++]
-------
#include "MyLED9.h"
#include "gpiocregisters.hpp"

void MyLED9::Execute()
{
    for(;;)
    {
      GPIOC::ODR::Toggle(1<<9U);
      Sleep(100ms);
    }
}
-------

Теперь для того чтобы данный код работал, необходимо в *main.cpp* создать задачу

.Файл main.cpp
[source, c++]
-------
#include "rtos.hpp"         // for Rtos
#include "mailbox.hpp"      // for Mailbox
#include "event.hpp"        // for Event

#include "rccregisters.hpp" // for RCC

#include "gpiocregisters.hpp"  // for GPIOC

// добавим библиотеки с описанием созданных классов двух светодиодов:
#include "myled.h"
#include "MyLED9.h"

std::uint32_t SystemCoreClock = 16'000'000U; // тактирование от внутреннего источника

extern "C" {
int __low_level_init(void)
{
  RCC::CR::HSION::On::Set();

  RCC::CFGR::SW::Hsi::Set();

  RCC::AHB1ENRPack<
      RCC::AHB1ENR::GPIOCEN::Enable
  >::Set();

  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  GPIOC::MODERPack<
      GPIOC::MODER::MODER8::Output,
      GPIOC::MODER::MODER9::Output
  >::Set();

  return 1;
}
}

//создадим объекты задач:
MyLED<GPIOC::ODR, 8> myledTask(200ms);
MyLED<GPIOC::ODR, 9> myled9Task(100ms);

int main()
{
  using namespace OsWrapper;
  // создали две задачи для светодиода 8, который должен мигать каждые 200 млсек. и светодиод 9 - 100 млсек.
  Rtos::CreateThread(myledTask, "myledTask");
  Rtos::CreateThread(myled9Task, "myled9Task",ThreadPriority::highest);
  Rtos::Start();
  return 0;
}
-------


== Вывод
Я узнала что такое операционная система реального времени и научилась создавать задачи.


