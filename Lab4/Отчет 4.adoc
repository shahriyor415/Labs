:imagesdir: Images
:toc:
:toc-title: Оглавление

[.text-center]
МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ +
Федеральное государственное автономное образовательное учреждение высшего образования +
«Южно-Уральский государственный университет» +
(национальный исследовательский университет) +
Высшая школа электроники и компьютерных наук +
Кафедра «Информационно-измерительная техника»

[.text-center]

Отчет по лабораторной работе №3

[.text-right]
Выполнили: +
студент группы КЭ-415 +
Хайдарзода Ш.Н.



== Задание к работе
    Написать программу, которая моргает всеми 4 светодиодами, но без использования магии с GPIOA::ODR::ODR5::High::Set() и тому подобное; а только прямой доступ к памяти по адресам, только хардкор.
А также в приложении к отчету нужно описать, как работает операция ИСКЛЮЧАЮЩЕЕ ИЛИ и как поменять значения переменных местами, без привлечения третьей переменной, ну т.е. Дано:
а = 3;
b = 4;
Чтобы не вводить 3 переменную. Чтобы не так:
с = a;
a = b;
b = c;
Не надо так, надо по другому.


== Написание программы для реализации моргания светодиодов
Напишем программу, которая реализует моргание светодиодов, т.е. одновременно зажигаются 4 светодиода.

Также подключим библиотеки "gpioaregisters.hpp" и "gpiocregisters.hpp" для того, чтобы зажигались все светодиоды.

Результат представлен ниже.

[source, c]
#include "gpioaregisters.hpp" //for GPIOA
#include "gpiocregisters.hpp" //for GPIOC
#include "rccregisters.hpp" //for RCC
std::uint32_t SystemCoreClock = 16'000'000U;
extern "C" {
int __low_level_init(void)
{
//Switch on external 16 MHz oscillator
RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{
}
//Switch system clock on external oscillator
RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{
}
RCC::APB2ENR::SYSCFGEN::Enable::Set();
return 1;
}
}
void delay(int cycles)
{
for(int i=0; i < cycles; ++i)
{
asm volatile ("");
}
}
int main()
{
RCC::AHB1ENR::GPIOAEN::Enable::Set();
RCC::AHB1ENR::GPIOCEN::Enable::Set();
GPIOA::MODER::MODER5::Output::Set();
GPIOC::MODER::MODER5::Output::Set();
GPIOC::MODER::MODER8::Output::Set();
GPIOC::MODER::MODER9::Output::Set();
//GPIOA::ODR::ODR5::High::Set();
uint32_t* ptrPaOdr = reinterpret_cast<uint32_t*>(0x40020014);
uint32_t* ptrPcOdr = reinterpret_cast<uint32_t*>(0x40020814);
for(;;)
{
*ptrPaOdr ^= static_cast<uint32_t>(1 << 5);
//1 << 5 = 000000b | 000010000b = 000010000b
/*
*ptrPaOdr |= static_cast<uint32_t>(1 << 5);
*ptrPaOdr &=~ static_cast<uint32_t>(1 << 5);
*/
*ptrPcOdr ^= static_cast<uint32_t>(1 << 5);
*ptrPcOdr ^= static_cast<uint32_t>(1 << 9);
*ptrPcOdr ^= static_cast<uint32_t>(1 << 8);
delay(1000000);
*ptrPaOdr ^= static_cast<uint32_t>(1 << 5);
*ptrPcOdr ^= static_cast<uint32_t>(1 << 5);
*ptrPcOdr ^= static_cast<uint32_t>(1 << 9);
*ptrPcOdr ^= static_cast<uint32_t>(1 << 8);
delay(1000000);
}
return 1;
}



== Подключение платы к компьютеру
Подключим отладчик к плате, и подключим плату к компьютеру. Результат представлен на рисунке 1.

image::DCfZK-oXxec.jpg[]

Рисунок 1 - Подключенная плата

Светодиод на отладчике горит красным, что говорит нам о том, что плата не прошита.

== Прошивка платы

Успешно прошиваем плату. Можем убедиться в этом, увидев поочередно горящие светодиоды на плате (бегущий огонь).
Результат представлен на рисунке 2.

image::IMG_0067.gif[]

Рисунок 2 - Прошитая плата

== Приложение

Оператор побитового исключающего или ( ^ ) сравнивает каждый бит своего первого операнда с соответствующим битом второго операнда. Если бит одного из операндов равен 0, а бит второго операнда равен 1, соответствующий бит результата устанавливается в значение 1. в противном случае — нулю.

Таблица истинности приведена ниже.

[cols=3*]
|===
|A
|B
|A xor B
|0
|1
|1
|1
|0
|1
|0
|0
|0
|1
|1
|0
|===

Для примера возьмем числа 0x5555 и 0xFFFF, которые равны соответственно 0101 и 1111. Согласно таблице истинности, после побитового сравнения должен получиться результат 1010. Если взять число 1010101010101010 и перевести в десятичную систему счисления, то мы получим число, равное 43690. Число 43690 будет отображаться как 0xAAAA. Следовательно, в окне Terminal I/O видим результат, равный AAAA.

Код реализации представлен ниже.

[source, c]
#include <iostream>
using namespace std;
int main()
{
unsigned short a = 0x5555;      //0101
unsigned short b = 0xFFFF;      //1111
cout  << hex << ( a ^ b ) << endl;   //"aaaa" 1010
}

Результат представлен на рисунке 3.

image::eCAHEn9S-AM.jpg[]

Рисунок 3 - Пример кода
