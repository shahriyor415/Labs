#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
#include "gpioaregisters.hpp" // регистр для порта a

#include <iostream>

int32_t timer = 1000000; // для задания частоты мигания светодиода
int8_t clic = 0; // Перебирает режимы кнопки (3 режима кнопки) 

  uint16_t st = 0x0280;
  uint16_t pt = 0x0140;  


//-----------------Функция задержки---------------------------------------------
int Delay(int value)
{
  for(int i = 0;i<value;++i)
  {
    volatile int j = i;
  }
}

//------------------------------Шаблонный класс Ёлочки--------------------------
template<typename TPort, int ...portNums>
class CristmasTree
{
private: // Модификатор, который запрещает доступ к свойствам класса из других частей программы
  static constexpr int portNum[] = {portNums...};
  static int inline currentLed = 0;

public: // Модификатор, который разрешает доступ к функции из главной функции main()
  static void Blink() // Функция (метод класса, который выполняет действие над свойствами данных)
  {
    TPort::Toggle(1 << portNum[currentLed]); // Переключает светодиод, с 1 на 0 и обратнод
    currentLed = ++currentLed == (sizeof...(portNums)) ? 0 : currentLed; // Перебирает все порты, и когда доходит до последнего, наинает с начала
  }
  
};
using MyGarland = CristmasTree<GPIOC::ODR, 6,9,8,7>; // Помещает в шаблонный класс наши данные о том какой порт задействуем и какие номера этого порта
//------------------------------------------------------------------------------

//------------------функция режима Ёлочка---------------------------------------
void Cristmas()
{
     MyGarland::Blink(); // Вызов функции из шаблонного класса, в которую помещает параметры из using MyGarland
     Delay(timer);  // Вызов функции задержки
}
//------------------------------------------------------------------------------

//---------------------Функция режима Мигалки-----------------------------------
void Migalka()
{
  GPIOC::ODR::Toggle((1 << 6) | (1 << 9) | (1<< 8) | (1<<7));
}

//---------------------Функция режима шахматы-----------------------------------
void Chess()
{
  GPIOC::ODR::Write(st);
  st=st^pt;
  pt=st^pt;
  st=st^pt;
}
//-----------------------------------------------------------------------------

//------------------------Функция для режимов кнопки-----------------------------
void ButtonRegimen(int8_t clicButton)
{
  if (clicButton==0) //если режим первый, то мигалка
  {
    Migalka();
  } 
  else if (clicButton==1) //если режим 2, то шахматы
  {
    Chess();
  } 
  else if (clicButton==2) // если режим 3, то ёлка
  {
    
    Cristmas();
  }
}




int main()
{ 
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт c перевести в режим вывода (с.6 c.7 c.8 c.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
  // подача тактирования на кнопку (кнопка - это вход)
  GPIOC::MODER::MODER13::Input::Set(); 
  
  for(;;)
  {
    
     
   if(GPIOC::IDR::IDR13::Low::IsSet()) // Если кнопка не нажата
   {
     while (GPIOC::IDR::IDR13::Low::IsSet()) // Если в како-то момент времени кнопка нажалась, то режим меняем
     {
     } 
     GPIOC::ODR::Write(0x0000); // сброс битов на светодиодах в 0
    
     if (clic<2)  // Всего 3 режима
     {
       clic++;
     }
     else 
     {
       clic=0;
     }
    
   }
// Если кнопка не нажата, то переходим по функциям с режимом
      ButtonRegimen(clic);
      Delay(timer);  
  }
  
}