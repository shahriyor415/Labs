---
title: Отчёт по передачи данных по UART и АЦП
---

:reproducible:

:description: Rabota_3
:keywords: AsciiDoc
:imagesdir: ImgRabota_3
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[text-right]
--
 Выполнила студентка группы КЭ-413
 Прокопьева Ксения
--
[.notes]

== USART
UART - это интерфейс по которому происходит обмен информацией.

Интерфейс деляться на 2 вида:

    Синхронные - когда программа отправила по интерфейсу запрос и ждёт пока ей не придёт ответ.

    Асинхронные - когда программа отправила по интерфейсц запрос и не дожидаясь ответа
начала выполнять свои функции, и в какой-то момент времени (в который программа ждать не будет)
может прийти ответное сообщение.

=== Таблица прерываний
В нашем микроконтролле имеется таблица прерываний для каждой периферии (file:///R:/POIP/POIP/stm32f411_1.pdf (с.201-204):

.Фрагмент таблицы прерываний
image::ФрагментТаблицыПрерываний.png[]

Согласно данной таблице можно определить положение UART относительно системного таймера:

.Позиция USART2
image::ПозицияUART.png[]

=== Алгоритм работы и настройка USART

1. Подключить USART к источнику тактирования – устанавливаем бит USART2EN в
регистре APB1ENR (АЦП тактируется от матрицы шин APB1).
2. Необходимо сконфигурировать порты. Настроить порты, на альтернативную функцию
нужного модуля USART.
3. Настроить формат передачи байт, с помощью регистра CR1 и CR2.
4. Задать скорость передачи с помощью регистра BRR.
5. Разрешить передачу помощью бита TE и если надо прием, с помощью бита RE в модуле
USART с помощью регистра CR1.
6. Включить сам модуль USART битом UE в регистре CR1.
7. Если работаем через прерывание, то разрешить глобальное прерывание для нужного
USART, в регистре ISER[1] модуля NVIC.
8. Если работаем через прерывание, в зависимости от того, что нам нужно, разрешить
прерывание по сигналу модуля UART (например, от сигнала регистр данных передачика
пуст (бит TXEIE в регистре CR1)).

Опишем функцию для передачи данных по USART в терминал. Создадим новым файл *Sender.h*

.Файл Sender.h
[source, c++]
-------
#ifndef  SENDER_H  //Защита от двойного подключения заголовочного файла
#define  SENDER_H  //Защита от двойного подключения заголовочного файла

#include <string>    // Библиотека типа данных строка

  template <typename TUSART> // Шаблонный класс, куда передаётся любой из USARTов
class Sender
{
  public:
   static void Send (std::string str) // Функция передачи данных
    {
      i = 0;                                         //Обнуление счётчика количества символов
      localStroka = str;                             // Перезапись отправляемого значения
      SendOneSymvol();                               // Вызов функции
      TUSART::CR1::TE::Enable::Set();                // Разрешаем передачу данных
      TUSART::CR1::TXEIE::InterruptWhenTXE::Set();   // Разрешаем прерывание
    }

   static void SendOneSymvol ()    //Функция отправки каждогов сивола
   {
     if (i > localStroka.size())   // если достигли конца строки
     {
       i = 0;                                         // Обнуляем счётчик
       TUSART::CR1::TE::Disable::Set();               // Запрешаем передачу
       TUSART::CR1::TXEIE::InterruptInhibited::Set(); // Запрещаем прерывание
     }
     else  // Если не достигли конца строки, то
     {
       TUSART::DR::Write(localStroka[i]);  // Записываем в регистр символ (1 байт)
       i++;                                // Переходим к следующему символу
     }
   }

   private:
   static inline std::string localStroka;    // Строка отправки
   static inline int32_t i = 0U;            // Счётчик колличества символов для отправки данных
};

#endif  //Конец заголовочного файла
-------

Настроим прерывание по опустошению буфера в файле *interrupthandler.hpp*.

.Файл interrupthandler.hpp
[source, c++]
-------
#include "usart2registers.hpp"   // Регистры USART для передачи данных
#include "Sender.h"             // Файл передачи данных по USART

static void USART2Handler() // Прервывание для USART2, вызыается когда опустошается регистр USART2::DR
    {
      if (USART2::SR::TXE::DataRegisterEmpty::IsSet() && USART2::CR1::TXEIE::InterruptWhenTXE::IsSet()) // Проверяем что регистр данных пуст USART2::SR::TXE и что разрешено прервание по передаче USART2::CR1::TXEIE
      {
        Sender<USART2>::SendOneSymvol(); // Функция передачи по 1 символу (по 1 байту), когда буфер опустошился, то передаём следующий символ
      }
    }
-------

Настроим порты для USART.
Для этого необходимо знать по каким портам может осуществляться передача и приём данных.
Для этого идём в даташит на STM32F411xC (file:///R:/POIP/POIP/stm32f411rc.pdf) и со страница 38 ищем порты отвечающие за USART.

.Порты отвечающие за USART2
image::НашлиПорта.png[]

Так как порты мы нашли, теперь необходимо перевести их в альтернативный режим, ибо порт будет передавать данные.
И настроим режим приёма и отпрвки.
Так как на одном порте альтернативных режимов может быть несколько, то найдём USART2 для портов PA2 и PA3 в том же даташите на странице 47.

.Настройка порта наприём/передачу
image::НастройкаПортаНаПриёмПередачу.png[]

Таким образом, согласно описанным действиям в файле *main.cpp* добавим следующий код:

.Файл main.cpp
[source, c++]
-------
...
#include "usart2registers.hpp"   // Регистры USART для передачи данных
...
int main()
{
...
//--------------------------------Передача данных-------------------------------

  RCC::APB1ENR::USART2EN::Enable::Set();      // Подать тактирование на USART
  NVIC::ISER1::Write(1U << 6U);              // UART = 38 позиция от системного таймера (38-32 = 6), разрешить глобальное прерывание

  GPIOA::MODER::MODER2::Alternate::Set();    // настройка порта А2  на альтернативный режим для передачи данных
  GPIOA::MODER::MODER3::Alternate::Set();   // настройка порта А3 на альтернативный режим для приёма данных
  GPIOA::AFRL::AFRL2::Af7::Set();          // перевели порт А2 в режим TX отправки
  GPIOA::AFRL::AFRL3::Af7::Set();         // перевели порт А3 в режим RX приёмки

  USART2::CR1::M::Data8bits::Set();              // передача данных по 8 бит
  USART2::CR1::TXEIE::InterruptWhenTXE::Set();  // разрешить прерывание по передаче
  USART2::CR1::TE::Enable::Set();              // разрешить передачу
  USART2::CR1::RE::Enable::Set();             // Разрешить приём

  USART2::CR2::STOP::Value0::Set();    // 1 стоповый бит

  uint32_t usartdiv = SystemClock/ (9600);   // расчёт скорости
  USART2::BRR::Write(usartdiv);             // целая часть скорости

  USART2::CR1::UE::Enable::Set();            // включение модуля USART
//------------------------------------------------------------------------------
...
//---------------------------вечный цикл----------------------------------------
  Delay(700);     // Задержка в миллисекундах
  for(;;)
  {
    userButton1.IsPressed() ;    // Если кнопка нажата
    if (flag == 1)
    {
      garland.UpdateCurrentMode(); // обновляем текущий режим светодиодов
      flag = 0;
      Sender<USART2>::Send(" Hello World "); // вывод слова в терминал
    }
}
-------

== АЦП

Аналого-цифровой преобразователь (АЦП) - это устройство, способное преобразовать аналоговый сигнал в дискретный.
АЦП состоит из компараторов. Компаратор - это такая штука, на вход которого подаётся заданный сигнал и сигнал сравнения,
а на выходе компаратора - формируются "0 - сигнал сравнения < заданного" и "1 - сигнал сравнения > заданного",
количество на выходе этих нулей и единиц отражает разрядность АЦП.
Другими словами, чем больше разрядность, тем точнее считает АЦП, но дольше.
АЦП в STM32F411RC 12 разрядное, имеющее 19 аналоговых каналов.
В один момент времени может быть задействован только 1 канал АЦП.
Запуск преобразования можно запускать по прерыванию.

=== Алгоритм запуска и настройки АЦП

1. Подключить АЦП к источнику тактирования –
устанавливаем бит ADC1EN в регистре RCC::APB2ENR (АЦП тактируется от шины APB2).
2. Сконфигурировать порты. Определиться по каким каналам будут проводиться измерения,
затем соответствующие выводы портов настроить для работы в аналоговом режиме.
3. Сконфигурировать АЦП.
4. Установить разрядность в регистре ADC::CR1
5. Установить режим одиночного преобразование в регистре ADC::CR1 (биты CONT и EOCS установить в нужное значение)
6. Установить количество измерений 1 в регистре ADC1::SQR1 бит L
7. Выбрать канал для первого преобразования в регистре ADC1::SQR3 биты SQ1
8. Установить скорость дискретизации в регистре SMPRx для нужного канала
9. Включить АЦП. Это делается установкой бита ADON в регистре ADC::CR2.
10. Запустить АЦП на преобразование установкой бита SWSTART в регистре ADC::CR2 для регулярных каналов
11. Дождаться готовности бита EOC в регистре ADC::SR
12. Считать данные из регистра ADC::DR

== Измерение температуры при помощи АЦП

Добавим в *main.cpp* следующий код:

.Файл main.cpp
[source, c++]
-------
#include "adc1registers.hpp"      // библиотека для АЦП
#include "adccommonregisters.hpp" // бибилиотека для TSVREFE - включения/отключения датчика температуры

#include <sstream>                // библиотека для преобразования числа в строку
...
//----------------------------------------АЦП-----------------------------------
  RCC::APB2ENR::ADC1EN::Enable::Set(); // подали тактирование на АЦП
  ADC1::CR1::RES::Bits12::Set();       // разрядность АЦП
  ADC1::SQR1::L::Conversions1::Set();  // количеств измерений (измерение один раз проводится)

  GPIOA::MODER::MODER0::Analog::Set(); // подали тактирование на порт А0

  ADC1::CR2::ADON::Enable::Set(); // включили АЦП

  ADC1::SQR3::SQ1::Channel18::Set();          // подключили 18 канал
  ADC1::SMPR2::SMP0::Cycles84::Set();         // скорость дискретизации
  ADC_Common::CCR::TSVREFE::Enable::Set();    // включили датчик температуры
//------------------------------------------------------------------------------
...
//---------------------------вечный цикл----------------------------------------
  Delay(700);     // Задержка в миллисекундах
  for(;;)
  {
    userButton1.IsPressed() ;    // Если кнопка нажата

    if (flag == 1)
    {
      garland.UpdateCurrentMode(); // обновляем текущий режим светодиодов
      flag = 0;
      ADC1::CR2::SWSTART::On::Set(); // запустили АЦП на измерение
      while( ADC1::SR::EOC::ConversionNotComplete::IsSet() )
      {
          // ждём пока закончится преобразование
      }

      float voltage = ADC1::DR::Get(); // считали значение с АЦП

      float V25 = 0.76;       // из даташина (cтр. 119) file:///R:/POIP/POIP/stm32f411rc.pdf
      float Avg_Slope = 2.5;  // оттуда же file:///R:/POIP/POIP/stm32f411rc.pdf
      double temperatura = ( (voltage*3.0f/4095.0f - V25) / Avg_Slope ) + 25; // Формула преобразования кода в температуру

      std::ostringstream ss; // поток, который конвертирует число в строку
      ss << temperatura;     // Преобразуем число в строку

      std::string outputstring (ss.str() + " "); // запись в outputstring строки с температурой
      Sender<USART2>::Send(outputstring);        // Вывод результата температуры в терминал
    }
      }
//------------------------------------------------------------------------------
-------

Температура измерена, однако её ещё нужно отклалибровать. Для этого отправимся в даташит:

.Информация о калибровке датчика температуры
image::КалибровкаДатчикаТемпературы.png[]

Соглассно данному рисунку, необходимо определить коды, соответствующие откалиброванным температурам в 30 и 110 градусов.
Сперва узнаем значения, лежащие по данным адресам. Значение представляет собой 16 битовое беззнаковое целое значение.
Допишем код, для того чтобы узнать эти значения:

.Функция main.cpp
[source, c++]
-------
...
      uint16_t T30 = *(uint16_t*)0x1FFF7A2C;  // код датчика температуры при 3,3 вольта при 30 градусах
      uint16_t T110 = *(uint16_t*)0x1FFF7A2E; // код датчика температуры на 3,3 вольта при 110 градусах

      cout << codeTemperature << "   " << T30 << "   "<< T110 << endl; // Вывод в консоль коды температур
}
-------

Таким образом вывели в консоль следующие значения:

.Калибровочные значения
image::КалибровочныеЗначения.png[]

Теперь рассчитаем точную температуру для моего кода температуры.
Для этого решим линейное уравнение:

.Решение линейного уравнения и нахождение истинной температуры по коду температуры
image::РешениеЛинейногоУравнения.png[]

Итого получили 27,16 градусов Цельсия.

Отколибруем теперь напряжение.
Для этого сперва нужно измерить опорное напряжение.
А для этого нужно подключиться к нужному каналу АЦП.

.Канал 17 для измеренния опорного напряжения
image::КаналДляИзмеренияОпорногоНапряжения.png[]

и напишем следующий код:

.Функция main.cpp
[source, c++]
-------
...
      // для калибровки напряжения
      uint16_t VREFINT_CAL = *(uint16_t*)0x1FFF7A2A;      // калибровочный код для 30 градусов
      uint16_t VREFINT_DATA = codeTemperature;           // код опорного напряжения
      float VDDA = 3.3 * VREFINT_DATA / VREFINT_CAL;    // опорное напряжене на плате

      cout << VREFINT_DATA << "   " << VREFINT_CAL << "   "<< VDDA << endl; // Вывод в консоль коды температур
      //------------------------------------------------------------------------
}
-------

Подключаемся вместо 16 канала к 17 и выводим в консоль кодовое значение опорного напряжения,
кодовое значение калибровоного значение, и действительное значение опорного напряжения.

.Кодовое значение опорного напряжения
image::КодовоеЗначениеОпорногоНапряжения.png[]

Теепрь рассчитаем калибровочную температуру, добавив в *main()*

.Функция main.cpp
[source, c++]
-------
...
      uint16_t codeTemperature = adc.GetResult();                                // считали значение из регистра ацп
      float temperatura = temperature.Calculate(codeTemperature);
      float calibrTemperatura = temperatura * (3.27f / 3.3f);                   // калибровочная температура
...
}
-------

Таким образом полуили неоткалиброванную и откалиброванную температуры:

.Неоткалиброванная и откалиброванная температуры
image::ЗначениеТемператур.png[]


== Вывод
Я научилась считывать температуру с АЦП.


